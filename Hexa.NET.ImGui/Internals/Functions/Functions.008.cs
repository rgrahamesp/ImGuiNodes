// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGuiP
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiNavItemDataPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiNavItemData self)
		{
			fixed (ImGuiNavItemData* pself = &self)
			{
				DestroyNative((ImGuiNavItemData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNative(ImGuiNavItemData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNavItemData*, void>)funcTable[903])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[903])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ImGuiNavItemDataPtr self)
		{
			ClearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ref ImGuiNavItemData self)
		{
			fixed (ImGuiNavItemData* pself = &self)
			{
				ClearNative((ImGuiNavItemData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTypingSelectState* ImGuiTypingSelectStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTypingSelectState*>)funcTable[904])();
			#else
			return (ImGuiTypingSelectState*)((delegate* unmanaged[Cdecl]<nint>)funcTable[904])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTypingSelectStatePtr ImGuiTypingSelectState()
		{
			ImGuiTypingSelectStatePtr ret = ImGuiTypingSelectStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiTypingSelectState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTypingSelectState*, void>)funcTable[905])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[905])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiTypingSelectStatePtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiTypingSelectState self)
		{
			fixed (ImGuiTypingSelectState* pself = &self)
			{
				DestroyNative((ImGuiTypingSelectState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNative(ImGuiTypingSelectState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTypingSelectState*, void>)funcTable[906])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[906])((nint)self);
			#endif
		}

		/// <summary>
		/// We preserve remaining data for easier debugging<br/>
		/// </summary>
		public static void Clear(ImGuiTypingSelectStatePtr self)
		{
			ClearNative(self);
		}

		/// <summary>
		/// We preserve remaining data for easier debugging<br/>
		/// </summary>
		public static void Clear(ref ImGuiTypingSelectState self)
		{
			fixed (ImGuiTypingSelectState* pself = &self)
			{
				ClearNative((ImGuiTypingSelectState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiOldColumnData* ImGuiOldColumnDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiOldColumnData*>)funcTable[907])();
			#else
			return (ImGuiOldColumnData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[907])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiOldColumnDataPtr ImGuiOldColumnData()
		{
			ImGuiOldColumnDataPtr ret = ImGuiOldColumnDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiOldColumnData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiOldColumnData*, void>)funcTable[908])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[908])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiOldColumnDataPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiOldColumnData self)
		{
			fixed (ImGuiOldColumnData* pself = &self)
			{
				DestroyNative((ImGuiOldColumnData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiOldColumns* ImGuiOldColumnsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiOldColumns*>)funcTable[909])();
			#else
			return (ImGuiOldColumns*)((delegate* unmanaged[Cdecl]<nint>)funcTable[909])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiOldColumnsPtr ImGuiOldColumns()
		{
			ImGuiOldColumnsPtr ret = ImGuiOldColumnsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiOldColumns* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiOldColumns*, void>)funcTable[910])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[910])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiOldColumnsPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiOldColumns self)
		{
			fixed (ImGuiOldColumns* pself = &self)
			{
				DestroyNative((ImGuiOldColumns*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiBoxSelectState* ImGuiBoxSelectStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiBoxSelectState*>)funcTable[911])();
			#else
			return (ImGuiBoxSelectState*)((delegate* unmanaged[Cdecl]<nint>)funcTable[911])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiBoxSelectStatePtr ImGuiBoxSelectState()
		{
			ImGuiBoxSelectStatePtr ret = ImGuiBoxSelectStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiBoxSelectState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiBoxSelectState*, void>)funcTable[912])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[912])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiBoxSelectStatePtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiBoxSelectState self)
		{
			fixed (ImGuiBoxSelectState* pself = &self)
			{
				DestroyNative((ImGuiBoxSelectState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiMultiSelectTempData* ImGuiMultiSelectTempDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMultiSelectTempData*>)funcTable[913])();
			#else
			return (ImGuiMultiSelectTempData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[913])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiMultiSelectTempDataPtr ImGuiMultiSelectTempData()
		{
			ImGuiMultiSelectTempDataPtr ret = ImGuiMultiSelectTempDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiMultiSelectTempData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMultiSelectTempData*, void>)funcTable[914])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[914])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiMultiSelectTempDataPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiMultiSelectTempData self)
		{
			fixed (ImGuiMultiSelectTempData* pself = &self)
			{
				DestroyNative((ImGuiMultiSelectTempData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNative(ImGuiMultiSelectTempData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMultiSelectTempData*, void>)funcTable[915])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[915])((nint)self);
			#endif
		}

		/// <summary>
		/// Zero-clear except IO as we preserve IO.Requests[] buffer allocation.<br/>
		/// </summary>
		public static void Clear(ImGuiMultiSelectTempDataPtr self)
		{
			ClearNative(self);
		}

		/// <summary>
		/// Zero-clear except IO as we preserve IO.Requests[] buffer allocation.<br/>
		/// </summary>
		public static void Clear(ref ImGuiMultiSelectTempData self)
		{
			fixed (ImGuiMultiSelectTempData* pself = &self)
			{
				ClearNative((ImGuiMultiSelectTempData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearIONative(ImGuiMultiSelectTempData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMultiSelectTempData*, void>)funcTable[916])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[916])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearIO(ImGuiMultiSelectTempDataPtr self)
		{
			ClearIONative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearIO(ref ImGuiMultiSelectTempData self)
		{
			fixed (ImGuiMultiSelectTempData* pself = &self)
			{
				ClearIONative((ImGuiMultiSelectTempData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiMultiSelectState* ImGuiMultiSelectStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMultiSelectState*>)funcTable[917])();
			#else
			return (ImGuiMultiSelectState*)((delegate* unmanaged[Cdecl]<nint>)funcTable[917])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiMultiSelectStatePtr ImGuiMultiSelectState()
		{
			ImGuiMultiSelectStatePtr ret = ImGuiMultiSelectStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiMultiSelectState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMultiSelectState*, void>)funcTable[918])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[918])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiMultiSelectStatePtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiMultiSelectState self)
		{
			fixed (ImGuiMultiSelectState* pself = &self)
			{
				DestroyNative((ImGuiMultiSelectState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiDockNode* ImGuiDockNodeNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiDockNode*>)funcTable[919])(id);
			#else
			return (ImGuiDockNode*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[919])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDockNodePtr ImGuiDockNode(uint id)
		{
			ImGuiDockNodePtr ret = ImGuiDockNodeNative(id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDockNode*, void>)funcTable[920])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[920])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiDockNodePtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				DestroyNative((ImGuiDockNode*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsRootNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[921])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[921])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsRootNode(ImGuiDockNodePtr self)
		{
			byte ret = IsRootNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsRootNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsRootNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsDockSpaceNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[922])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[922])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsDockSpace(ImGuiDockNodePtr self)
		{
			byte ret = IsDockSpaceNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsDockSpace(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsDockSpaceNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsFloatingNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[923])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[923])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsFloatingNode(ImGuiDockNodePtr self)
		{
			byte ret = IsFloatingNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsFloatingNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsFloatingNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsCentralNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[924])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[924])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsCentralNode(ImGuiDockNodePtr self)
		{
			byte ret = IsCentralNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsCentralNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsCentralNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// Hidden tab bar can be shown back by clicking the small triangle<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsHiddenTabBarNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[925])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[925])((nint)self);
			#endif
		}

		/// <summary>
		/// Hidden tab bar can be shown back by clicking the small triangle<br/>
		/// </summary>
		public static bool IsHiddenTabBar(ImGuiDockNodePtr self)
		{
			byte ret = IsHiddenTabBarNative(self);
			return ret != 0;
		}

		/// <summary>
		/// Hidden tab bar can be shown back by clicking the small triangle<br/>
		/// </summary>
		public static bool IsHiddenTabBar(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsHiddenTabBarNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// Never show a tab bar<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsNoTabBarNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[926])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[926])((nint)self);
			#endif
		}

		/// <summary>
		/// Never show a tab bar<br/>
		/// </summary>
		public static bool IsNoTabBar(ImGuiDockNodePtr self)
		{
			byte ret = IsNoTabBarNative(self);
			return ret != 0;
		}

		/// <summary>
		/// Never show a tab bar<br/>
		/// </summary>
		public static bool IsNoTabBar(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsNoTabBarNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsSplitNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[927])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[927])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsSplitNode(ImGuiDockNodePtr self)
		{
			byte ret = IsSplitNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsSplitNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsSplitNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsLeafNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[928])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[928])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsLeafNode(ImGuiDockNodePtr self)
		{
			byte ret = IsLeafNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsLeafNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsLeafNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsEmptyNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[929])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[929])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsEmpty(ImGuiDockNodePtr self)
		{
			byte ret = IsEmptyNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsEmpty(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsEmptyNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RectNative(ImRect* pOut, ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiDockNode*, void>)funcTable[930])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[930])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect Rect(ImGuiDockNodePtr self)
		{
			ImRect ret;
			RectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ImRectPtr pOut, ImGuiDockNodePtr self)
		{
			RectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ref ImRect pOut, ImGuiDockNodePtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				RectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect Rect(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				ImRect ret;
				RectNative(&ret, (ImGuiDockNode*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ImRectPtr pOut, ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				RectNative(pOut, (ImGuiDockNode*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ref ImRect pOut, ref ImGuiDockNode self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiDockNode* pself = &self)
				{
					RectNative((ImRect*)ppOut, (ImGuiDockNode*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetLocalFlagsNative(ImGuiDockNode* self, ImGuiDockNodeFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDockNode*, ImGuiDockNodeFlags, void>)funcTable[931])(self, flags);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiDockNodeFlags, void>)funcTable[931])((nint)self, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetLocalFlags(ImGuiDockNodePtr self, ImGuiDockNodeFlags flags)
		{
			SetLocalFlagsNative(self, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetLocalFlags(ref ImGuiDockNode self, ImGuiDockNodeFlags flags)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				SetLocalFlagsNative((ImGuiDockNode*)pself, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateMergedFlagsNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDockNode*, void>)funcTable[932])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[932])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateMergedFlags(ImGuiDockNodePtr self)
		{
			UpdateMergedFlagsNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateMergedFlags(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				UpdateMergedFlagsNative((ImGuiDockNode*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiDockContext* ImGuiDockContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockContext*>)funcTable[933])();
			#else
			return (ImGuiDockContext*)((delegate* unmanaged[Cdecl]<nint>)funcTable[933])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDockContextPtr ImGuiDockContext()
		{
			ImGuiDockContextPtr ret = ImGuiDockContextNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiDockContext* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDockContext*, void>)funcTable[934])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[934])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiDockContextPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiDockContext self)
		{
			fixed (ImGuiDockContext* pself = &self)
			{
				DestroyNative((ImGuiDockContext*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiViewportP* ImGuiViewportPNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiViewportP*>)funcTable[935])();
			#else
			return (ImGuiViewportP*)((delegate* unmanaged[Cdecl]<nint>)funcTable[935])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiViewportPPtr ImGuiViewportP()
		{
			ImGuiViewportPPtr ret = ImGuiViewportPNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiViewportP*, void>)funcTable[936])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[936])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiViewportPPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				DestroyNative((ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearRequestFlagsNative(ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiViewportP*, void>)funcTable[937])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[937])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearRequestFlags(ImGuiViewportPPtr self)
		{
			ClearRequestFlagsNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearRequestFlags(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ClearRequestFlagsNative((ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalcWorkRectPosNative(Vector2* pOut, ImGuiViewportP* self, Vector2 insetMin)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImGuiViewportP*, Vector2, void>)funcTable[938])(pOut, self, insetMin);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, Vector2, void>)funcTable[938])((nint)pOut, (nint)self, insetMin);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcWorkRectPos(ImGuiViewportPPtr self, Vector2 insetMin)
		{
			Vector2 ret;
			CalcWorkRectPosNative(&ret, self, insetMin);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectPos(Vector2* pOut, ImGuiViewportPPtr self, Vector2 insetMin)
		{
			CalcWorkRectPosNative(pOut, self, insetMin);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectPos(ref Vector2 pOut, ImGuiViewportPPtr self, Vector2 insetMin)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcWorkRectPosNative((Vector2*)ppOut, self, insetMin);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcWorkRectPos(ref ImGuiViewportP self, Vector2 insetMin)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				Vector2 ret;
				CalcWorkRectPosNative(&ret, (ImGuiViewportP*)pself, insetMin);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectPos(Vector2* pOut, ref ImGuiViewportP self, Vector2 insetMin)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				CalcWorkRectPosNative(pOut, (ImGuiViewportP*)pself, insetMin);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectPos(ref Vector2 pOut, ref ImGuiViewportP self, Vector2 insetMin)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					CalcWorkRectPosNative((Vector2*)ppOut, (ImGuiViewportP*)pself, insetMin);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalcWorkRectSizeNative(Vector2* pOut, ImGuiViewportP* self, Vector2 insetMin, Vector2 insetMax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImGuiViewportP*, Vector2, Vector2, void>)funcTable[939])(pOut, self, insetMin, insetMax);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, Vector2, Vector2, void>)funcTable[939])((nint)pOut, (nint)self, insetMin, insetMax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcWorkRectSize(ImGuiViewportPPtr self, Vector2 insetMin, Vector2 insetMax)
		{
			Vector2 ret;
			CalcWorkRectSizeNative(&ret, self, insetMin, insetMax);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectSize(Vector2* pOut, ImGuiViewportPPtr self, Vector2 insetMin, Vector2 insetMax)
		{
			CalcWorkRectSizeNative(pOut, self, insetMin, insetMax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectSize(ref Vector2 pOut, ImGuiViewportPPtr self, Vector2 insetMin, Vector2 insetMax)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcWorkRectSizeNative((Vector2*)ppOut, self, insetMin, insetMax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcWorkRectSize(ref ImGuiViewportP self, Vector2 insetMin, Vector2 insetMax)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				Vector2 ret;
				CalcWorkRectSizeNative(&ret, (ImGuiViewportP*)pself, insetMin, insetMax);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectSize(Vector2* pOut, ref ImGuiViewportP self, Vector2 insetMin, Vector2 insetMax)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				CalcWorkRectSizeNative(pOut, (ImGuiViewportP*)pself, insetMin, insetMax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectSize(ref Vector2 pOut, ref ImGuiViewportP self, Vector2 insetMin, Vector2 insetMax)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					CalcWorkRectSizeNative((Vector2*)ppOut, (ImGuiViewportP*)pself, insetMin, insetMax);
				}
			}
		}

		/// <summary>
		/// Update public fields<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateWorkRectNative(ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiViewportP*, void>)funcTable[940])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[940])((nint)self);
			#endif
		}

		/// <summary>
		/// Update public fields<br/>
		/// </summary>
		public static void UpdateWorkRect(ImGuiViewportPPtr self)
		{
			UpdateWorkRectNative(self);
		}

		/// <summary>
		/// Update public fields<br/>
		/// </summary>
		public static void UpdateWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				UpdateWorkRectNative((ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMainRectNative(ImRect* pOut, ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiViewportP*, void>)funcTable[941])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[941])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetMainRect(ImGuiViewportPPtr self)
		{
			ImRect ret;
			GetMainRectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetMainRect(ImRectPtr pOut, ImGuiViewportPPtr self)
		{
			GetMainRectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetMainRect(ref ImRect pOut, ImGuiViewportPPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				GetMainRectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetMainRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				GetMainRectNative(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetMainRect(ImRectPtr pOut, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				GetMainRectNative(pOut, (ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetMainRect(ref ImRect pOut, ref ImGuiViewportP self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					GetMainRectNative((ImRect*)ppOut, (ImGuiViewportP*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetWorkRectNative(ImRect* pOut, ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiViewportP*, void>)funcTable[942])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[942])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetWorkRect(ImGuiViewportPPtr self)
		{
			ImRect ret;
			GetWorkRectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetWorkRect(ImRectPtr pOut, ImGuiViewportPPtr self)
		{
			GetWorkRectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetWorkRect(ref ImRect pOut, ImGuiViewportPPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				GetWorkRectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				GetWorkRectNative(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetWorkRect(ImRectPtr pOut, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				GetWorkRectNative(pOut, (ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetWorkRect(ref ImRect pOut, ref ImGuiViewportP self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					GetWorkRectNative((ImRect*)ppOut, (ImGuiViewportP*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBuildWorkRectNative(ImRect* pOut, ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiViewportP*, void>)funcTable[943])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[943])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetBuildWorkRect(ImGuiViewportPPtr self)
		{
			ImRect ret;
			GetBuildWorkRectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBuildWorkRect(ImRectPtr pOut, ImGuiViewportPPtr self)
		{
			GetBuildWorkRectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBuildWorkRect(ref ImRect pOut, ImGuiViewportPPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				GetBuildWorkRectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetBuildWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				GetBuildWorkRectNative(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBuildWorkRect(ImRectPtr pOut, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				GetBuildWorkRectNative(pOut, (ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBuildWorkRect(ref ImRect pOut, ref ImGuiViewportP self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					GetBuildWorkRectNative((ImRect*)ppOut, (ImGuiViewportP*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiWindowSettings* ImGuiWindowSettingsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindowSettings*>)funcTable[944])();
			#else
			return (ImGuiWindowSettings*)((delegate* unmanaged[Cdecl]<nint>)funcTable[944])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowSettingsPtr ImGuiWindowSettings()
		{
			ImGuiWindowSettingsPtr ret = ImGuiWindowSettingsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiWindowSettings* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindowSettings*, void>)funcTable[945])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[945])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiWindowSettingsPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				DestroyNative((ImGuiWindowSettings*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetNameNative(ImGuiWindowSettings* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindowSettings*, byte*>)funcTable[946])(self);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[946])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetName(ImGuiWindowSettingsPtr self)
		{
			byte* ret = GetNameNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetNameS(ImGuiWindowSettingsPtr self)
		{
			string ret = Utils.DecodeStringUTF8(GetNameNative(self));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetName(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				byte* ret = GetNameNative((ImGuiWindowSettings*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetNameS(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(GetNameNative((ImGuiWindowSettings*)pself));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiSettingsHandler* ImGuiSettingsHandlerNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiSettingsHandler*>)funcTable[947])();
			#else
			return (ImGuiSettingsHandler*)((delegate* unmanaged[Cdecl]<nint>)funcTable[947])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiSettingsHandlerPtr ImGuiSettingsHandler()
		{
			ImGuiSettingsHandlerPtr ret = ImGuiSettingsHandlerNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiSettingsHandler* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiSettingsHandler*, void>)funcTable[948])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[948])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiSettingsHandlerPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiSettingsHandler self)
		{
			fixed (ImGuiSettingsHandler* pself = &self)
			{
				DestroyNative((ImGuiSettingsHandler*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiDebugAllocInfo* ImGuiDebugAllocInfoNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDebugAllocInfo*>)funcTable[949])();
			#else
			return (ImGuiDebugAllocInfo*)((delegate* unmanaged[Cdecl]<nint>)funcTable[949])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDebugAllocInfoPtr ImGuiDebugAllocInfo()
		{
			ImGuiDebugAllocInfoPtr ret = ImGuiDebugAllocInfoNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiDebugAllocInfo* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDebugAllocInfo*, void>)funcTable[950])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[950])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiDebugAllocInfoPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiDebugAllocInfo self)
		{
			fixed (ImGuiDebugAllocInfo* pself = &self)
			{
				DestroyNative((ImGuiDebugAllocInfo*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiStackLevelInfo* ImGuiStackLevelInfoNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStackLevelInfo*>)funcTable[951])();
			#else
			return (ImGuiStackLevelInfo*)((delegate* unmanaged[Cdecl]<nint>)funcTable[951])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStackLevelInfoPtr ImGuiStackLevelInfo()
		{
			ImGuiStackLevelInfoPtr ret = ImGuiStackLevelInfoNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiStackLevelInfo* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStackLevelInfo*, void>)funcTable[952])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[952])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiStackLevelInfoPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiStackLevelInfo self)
		{
			fixed (ImGuiStackLevelInfo* pself = &self)
			{
				DestroyNative((ImGuiStackLevelInfo*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiIDStackTool* ImGuiIDStackToolNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiIDStackTool*>)funcTable[953])();
			#else
			return (ImGuiIDStackTool*)((delegate* unmanaged[Cdecl]<nint>)funcTable[953])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiIDStackToolPtr ImGuiIDStackTool()
		{
			ImGuiIDStackToolPtr ret = ImGuiIDStackToolNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiIDStackTool* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIDStackTool*, void>)funcTable[954])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[954])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiIDStackToolPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiIDStackTool self)
		{
			fixed (ImGuiIDStackTool* pself = &self)
			{
				DestroyNative((ImGuiIDStackTool*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiContextHook* ImGuiContextHookNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContextHook*>)funcTable[955])();
			#else
			return (ImGuiContextHook*)((delegate* unmanaged[Cdecl]<nint>)funcTable[955])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextHookPtr ImGuiContextHook()
		{
			ImGuiContextHookPtr ret = ImGuiContextHookNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiContextHook* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContextHook*, void>)funcTable[956])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[956])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiContextHookPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiContextHook self)
		{
			fixed (ImGuiContextHook* pself = &self)
			{
				DestroyNative((ImGuiContextHook*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiContext* ImGuiContextNative(ImFontAtlas* sharedFontAtlas)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImFontAtlas*, ImGuiContext*>)funcTable[957])(sharedFontAtlas);
			#else
			return (ImGuiContext*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[957])((nint)sharedFontAtlas);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextPtr ImGuiContext(ImFontAtlasPtr sharedFontAtlas)
		{
			ImGuiContextPtr ret = ImGuiContextNative(sharedFontAtlas);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextPtr ImGuiContext(ref ImFontAtlas sharedFontAtlas)
		{
			fixed (ImFontAtlas* psharedFontAtlas = &sharedFontAtlas)
			{
				ImGuiContextPtr ret = ImGuiContextNative((ImFontAtlas*)psharedFontAtlas);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiContext* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiContext*, void>)funcTable[958])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[958])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiContextPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiContext self)
		{
			fixed (ImGuiContext* pself = &self)
			{
				DestroyNative((ImGuiContext*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiWindow* ImGuiWindowNative(ImGuiContext* context, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContext*, byte*, ImGuiWindow*>)funcTable[959])(context, name);
			#else
			return (ImGuiWindow*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[959])((nint)context, (nint)name);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr ImGuiWindow(ImGuiContextPtr context, byte* name)
		{
			ImGuiWindowPtr ret = ImGuiWindowNative(context, name);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr ImGuiWindow(ref ImGuiContext context, byte* name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				ImGuiWindowPtr ret = ImGuiWindowNative((ImGuiContext*)pcontext, name);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr ImGuiWindow(ImGuiContextPtr context, ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ImGuiWindowPtr ret = ImGuiWindowNative(context, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr ImGuiWindow(ImGuiContextPtr context, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				ImGuiWindowPtr ret = ImGuiWindowNative(context, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr ImGuiWindow(ImGuiContextPtr context, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiWindowPtr ret = ImGuiWindowNative(context, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr ImGuiWindow(ref ImGuiContext context, ref byte name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				fixed (byte* pname = &name)
				{
					ImGuiWindowPtr ret = ImGuiWindowNative((ImGuiContext*)pcontext, (byte*)pname);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr ImGuiWindow(ref ImGuiContext context, ReadOnlySpan<byte> name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				fixed (byte* pname = name)
				{
					ImGuiWindowPtr ret = ImGuiWindowNative((ImGuiContext*)pcontext, (byte*)pname);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr ImGuiWindow(ref ImGuiContext context, string name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiWindowPtr ret = ImGuiWindowNative((ImGuiContext*)pcontext, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiWindow* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, void>)funcTable[960])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[960])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiWindowPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				DestroyNative((ImGuiWindow*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIDNative(ImGuiWindow* self, byte* str, byte* strEnd)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, byte*, byte*, uint>)funcTable[961])(self, str, strEnd);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, uint>)funcTable[961])((nint)self, (nint)str, (nint)strEnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, byte* str, byte* strEnd)
		{
			uint ret = GetIDNative(self, str, strEnd);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, byte* str)
		{
			uint ret = GetIDNative(self, str, (byte*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, byte* str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				uint ret = GetIDNative((ImGuiWindow*)pself, str, strEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, byte* str)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				uint ret = GetIDNative((ImGuiWindow*)pself, str, (byte*)(default));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ref byte str, byte* strEnd)
		{
			fixed (byte* pstr = &str)
			{
				uint ret = GetIDNative(self, (byte*)pstr, strEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				uint ret = GetIDNative(self, (byte*)pstr, (byte*)(default));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ReadOnlySpan<byte> str, byte* strEnd)
		{
			fixed (byte* pstr = str)
			{
				uint ret = GetIDNative(self, (byte*)pstr, strEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				uint ret = GetIDNative(self, (byte*)pstr, (byte*)(default));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, string str, byte* strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetIDNative(self, pStr0, strEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetIDNative(self, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ref byte str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, strEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ref byte str)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, (byte*)(default));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ReadOnlySpan<byte> str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = str)
				{
					uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, strEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ReadOnlySpan<byte> str)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = str)
				{
					uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, (byte*)(default));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, string str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				uint ret = GetIDNative((ImGuiWindow*)pself, pStr0, strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, string str)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				uint ret = GetIDNative((ImGuiWindow*)pself, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, byte* str, ref byte strEnd)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				uint ret = GetIDNative(self, str, (byte*)pstrEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, byte* str, ReadOnlySpan<byte> strEnd)
		{
			fixed (byte* pstrEnd = strEnd)
			{
				uint ret = GetIDNative(self, str, (byte*)pstrEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, byte* str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetIDNative(self, str, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, byte* str, ref byte strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					uint ret = GetIDNative((ImGuiWindow*)pself, str, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, byte* str, ReadOnlySpan<byte> strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstrEnd = strEnd)
				{
					uint ret = GetIDNative((ImGuiWindow*)pself, str, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, byte* str, string strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				uint ret = GetIDNative((ImGuiWindow*)pself, str, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ref byte str, ref byte strEnd)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					uint ret = GetIDNative(self, (byte*)pstr, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ReadOnlySpan<byte> str, ReadOnlySpan<byte> strEnd)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte* pstrEnd = strEnd)
				{
					uint ret = GetIDNative(self, (byte*)pstr, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, string str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			uint ret = GetIDNative(self, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ref byte str, ReadOnlySpan<byte> strEnd)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pstrEnd = strEnd)
				{
					uint ret = GetIDNative(self, (byte*)pstr, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ref byte str, string strEnd)
		{
			fixed (byte* pstr = &str)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				uint ret = GetIDNative(self, (byte*)pstr, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ReadOnlySpan<byte> str, ref byte strEnd)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					uint ret = GetIDNative(self, (byte*)pstr, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ReadOnlySpan<byte> str, string strEnd)
		{
			fixed (byte* pstr = str)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				uint ret = GetIDNative(self, (byte*)pstr, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, string str, ref byte strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstrEnd = &strEnd)
			{
				uint ret = GetIDNative(self, pStr0, (byte*)pstrEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, string str, ReadOnlySpan<byte> strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstrEnd = strEnd)
			{
				uint ret = GetIDNative(self, pStr0, (byte*)pstrEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ref byte str, ref byte strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					fixed (byte* pstrEnd = &strEnd)
					{
						uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, (byte*)pstrEnd);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ReadOnlySpan<byte> str, ReadOnlySpan<byte> strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = str)
				{
					fixed (byte* pstrEnd = strEnd)
					{
						uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, (byte*)pstrEnd);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, string str, string strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (strEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				uint ret = GetIDNative((ImGuiWindow*)pself, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ref byte str, ReadOnlySpan<byte> strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					fixed (byte* pstrEnd = strEnd)
					{
						uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, (byte*)pstrEnd);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ref byte str, string strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (strEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(strEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ReadOnlySpan<byte> str, ref byte strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = str)
				{
					fixed (byte* pstrEnd = &strEnd)
					{
						uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, (byte*)pstrEnd);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ReadOnlySpan<byte> str, string strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = str)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (strEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(strEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, string str, ref byte strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pstrEnd = &strEnd)
				{
					uint ret = GetIDNative((ImGuiWindow*)pself, pStr0, (byte*)pstrEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, string str, ReadOnlySpan<byte> strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pstrEnd = strEnd)
				{
					uint ret = GetIDNative((ImGuiWindow*)pself, pStr0, (byte*)pstrEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIDNative(ImGuiWindow* self, void* ptr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, void*, uint>)funcTable[962])(self, ptr);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[962])((nint)self, (nint)ptr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, void* ptr)
		{
			uint ret = GetIDNative(self, ptr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, void* ptr)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				uint ret = GetIDNative((ImGuiWindow*)pself, ptr);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIDNative(ImGuiWindow* self, int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, int, uint>)funcTable[963])(self, n);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, uint>)funcTable[963])((nint)self, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, int n)
		{
			uint ret = GetIDNative(self, n);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, int n)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				uint ret = GetIDNative((ImGuiWindow*)pself, n);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIDFromPosNative(ImGuiWindow* self, Vector2 pAbs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, Vector2, uint>)funcTable[964])(self, pAbs);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, Vector2, uint>)funcTable[964])((nint)self, pAbs);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDFromPos(ImGuiWindowPtr self, Vector2 pAbs)
		{
			uint ret = GetIDFromPosNative(self, pAbs);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDFromPos(ref ImGuiWindow self, Vector2 pAbs)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				uint ret = GetIDFromPosNative((ImGuiWindow*)pself, pAbs);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIDFromRectangleNative(ImGuiWindow* self, ImRect rAbs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImRect, uint>)funcTable[965])(self, rAbs);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, ImRect, uint>)funcTable[965])((nint)self, rAbs);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDFromRectangle(ImGuiWindowPtr self, ImRect rAbs)
		{
			uint ret = GetIDFromRectangleNative(self, rAbs);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDFromRectangle(ref ImGuiWindow self, ImRect rAbs)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				uint ret = GetIDFromRectangleNative((ImGuiWindow*)pself, rAbs);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RectNative(ImRect* pOut, ImGuiWindow* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiWindow*, void>)funcTable[966])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[966])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect Rect(ImGuiWindowPtr self)
		{
			ImRect ret;
			RectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ImRectPtr pOut, ImGuiWindowPtr self)
		{
			RectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ref ImRect pOut, ImGuiWindowPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				RectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect Rect(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImRect ret;
				RectNative(&ret, (ImGuiWindow*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ImRectPtr pOut, ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				RectNative(pOut, (ImGuiWindow*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ref ImRect pOut, ref ImGuiWindow self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pself = &self)
				{
					RectNative((ImRect*)ppOut, (ImGuiWindow*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float CalcFontSizeNative(ImGuiWindow* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, float>)funcTable[967])(self);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)funcTable[967])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float CalcFontSize(ImGuiWindowPtr self)
		{
			float ret = CalcFontSizeNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float CalcFontSize(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				float ret = CalcFontSizeNative((ImGuiWindow*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TitleBarRectNative(ImRect* pOut, ImGuiWindow* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiWindow*, void>)funcTable[968])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[968])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect TitleBarRect(ImGuiWindowPtr self)
		{
			ImRect ret;
			TitleBarRectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TitleBarRect(ImRectPtr pOut, ImGuiWindowPtr self)
		{
			TitleBarRectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TitleBarRect(ref ImRect pOut, ImGuiWindowPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				TitleBarRectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect TitleBarRect(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImRect ret;
				TitleBarRectNative(&ret, (ImGuiWindow*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TitleBarRect(ImRectPtr pOut, ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				TitleBarRectNative(pOut, (ImGuiWindow*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TitleBarRect(ref ImRect pOut, ref ImGuiWindow self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pself = &self)
				{
					TitleBarRectNative((ImRect*)ppOut, (ImGuiWindow*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MenuBarRectNative(ImRect* pOut, ImGuiWindow* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiWindow*, void>)funcTable[969])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[969])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect MenuBarRect(ImGuiWindowPtr self)
		{
			ImRect ret;
			MenuBarRectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MenuBarRect(ImRectPtr pOut, ImGuiWindowPtr self)
		{
			MenuBarRectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MenuBarRect(ref ImRect pOut, ImGuiWindowPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				MenuBarRectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect MenuBarRect(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImRect ret;
				MenuBarRectNative(&ret, (ImGuiWindow*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MenuBarRect(ImRectPtr pOut, ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				MenuBarRectNative(pOut, (ImGuiWindow*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MenuBarRect(ref ImRect pOut, ref ImGuiWindow self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pself = &self)
				{
					MenuBarRectNative((ImRect*)ppOut, (ImGuiWindow*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTabItem* ImGuiTabItemNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTabItem*>)funcTable[970])();
			#else
			return (ImGuiTabItem*)((delegate* unmanaged[Cdecl]<nint>)funcTable[970])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTabItemPtr ImGuiTabItem()
		{
			ImGuiTabItemPtr ret = ImGuiTabItemNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiTabItem* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTabItem*, void>)funcTable[971])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[971])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiTabItemPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiTabItem self)
		{
			fixed (ImGuiTabItem* pself = &self)
			{
				DestroyNative((ImGuiTabItem*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTabBar* ImGuiTabBarNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTabBar*>)funcTable[972])();
			#else
			return (ImGuiTabBar*)((delegate* unmanaged[Cdecl]<nint>)funcTable[972])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTabBarPtr ImGuiTabBar()
		{
			ImGuiTabBarPtr ret = ImGuiTabBarNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiTabBar* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTabBar*, void>)funcTable[973])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[973])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiTabBarPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiTabBar self)
		{
			fixed (ImGuiTabBar* pself = &self)
			{
				DestroyNative((ImGuiTabBar*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTableColumn* ImGuiTableColumnNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTableColumn*>)funcTable[974])();
			#else
			return (ImGuiTableColumn*)((delegate* unmanaged[Cdecl]<nint>)funcTable[974])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableColumnPtr ImGuiTableColumn()
		{
			ImGuiTableColumnPtr ret = ImGuiTableColumnNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiTableColumn* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTableColumn*, void>)funcTable[975])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[975])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiTableColumnPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiTableColumn self)
		{
			fixed (ImGuiTableColumn* pself = &self)
			{
				DestroyNative((ImGuiTableColumn*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTableInstanceData* ImGuiTableInstanceDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTableInstanceData*>)funcTable[976])();
			#else
			return (ImGuiTableInstanceData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[976])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableInstanceDataPtr ImGuiTableInstanceData()
		{
			ImGuiTableInstanceDataPtr ret = ImGuiTableInstanceDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiTableInstanceData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTableInstanceData*, void>)funcTable[977])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[977])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiTableInstanceDataPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiTableInstanceData self)
		{
			fixed (ImGuiTableInstanceData* pself = &self)
			{
				DestroyNative((ImGuiTableInstanceData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTable* ImGuiTableNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*>)funcTable[978])();
			#else
			return (ImGuiTable*)((delegate* unmanaged[Cdecl]<nint>)funcTable[978])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTablePtr ImGuiTable()
		{
			ImGuiTablePtr ret = ImGuiTableNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiTable* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)funcTable[979])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[979])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiTablePtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiTable self)
		{
			fixed (ImGuiTable* pself = &self)
			{
				DestroyNative((ImGuiTable*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTableTempData* ImGuiTableTempDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTableTempData*>)funcTable[980])();
			#else
			return (ImGuiTableTempData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[980])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableTempDataPtr ImGuiTableTempData()
		{
			ImGuiTableTempDataPtr ret = ImGuiTableTempDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiTableTempData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTableTempData*, void>)funcTable[981])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[981])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiTableTempDataPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiTableTempData self)
		{
			fixed (ImGuiTableTempData* pself = &self)
			{
				DestroyNative((ImGuiTableTempData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTableColumnSettings* ImGuiTableColumnSettingsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTableColumnSettings*>)funcTable[982])();
			#else
			return (ImGuiTableColumnSettings*)((delegate* unmanaged[Cdecl]<nint>)funcTable[982])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableColumnSettingsPtr ImGuiTableColumnSettings()
		{
			ImGuiTableColumnSettingsPtr ret = ImGuiTableColumnSettingsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiTableColumnSettings* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTableColumnSettings*, void>)funcTable[983])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[983])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiTableColumnSettingsPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiTableColumnSettings self)
		{
			fixed (ImGuiTableColumnSettings* pself = &self)
			{
				DestroyNative((ImGuiTableColumnSettings*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTableSettings* ImGuiTableSettingsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTableSettings*>)funcTable[984])();
			#else
			return (ImGuiTableSettings*)((delegate* unmanaged[Cdecl]<nint>)funcTable[984])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableSettingsPtr ImGuiTableSettings()
		{
			ImGuiTableSettingsPtr ret = ImGuiTableSettingsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiTableSettings* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTableSettings*, void>)funcTable[985])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[985])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiTableSettingsPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiTableSettings self)
		{
			fixed (ImGuiTableSettings* pself = &self)
			{
				DestroyNative((ImGuiTableSettings*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTableColumnSettings* GetColumnSettingsNative(ImGuiTableSettings* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTableSettings*, ImGuiTableColumnSettings*>)funcTable[986])(self);
			#else
			return (ImGuiTableColumnSettings*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[986])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableColumnSettingsPtr GetColumnSettings(ImGuiTableSettingsPtr self)
		{
			ImGuiTableColumnSettingsPtr ret = GetColumnSettingsNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableColumnSettingsPtr GetColumnSettings(ref ImGuiTableSettings self)
		{
			fixed (ImGuiTableSettings* pself = &self)
			{
				ImGuiTableColumnSettingsPtr ret = GetColumnSettingsNative((ImGuiTableSettings*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiIO* GetIOExNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiIO*>)funcTable[987])(ctx);
			#else
			return (ImGuiIO*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[987])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiIOPtr GetIOEx(ImGuiContextPtr ctx)
		{
			ImGuiIOPtr ret = GetIOExNative(ctx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiIOPtr GetIOEx(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiIOPtr ret = GetIOExNative((ImGuiContext*)pctx);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiPlatformIO* GetPlatformIOExNative(ImGuiContext* ctx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContext*, ImGuiPlatformIO*>)funcTable[988])(ctx);
			#else
			return (ImGuiPlatformIO*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[988])((nint)ctx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiPlatformIOPtr GetPlatformIOEx(ImGuiContextPtr ctx)
		{
			ImGuiPlatformIOPtr ret = GetPlatformIOExNative(ctx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiPlatformIOPtr GetPlatformIOEx(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiPlatformIOPtr ret = GetPlatformIOExNative((ImGuiContext*)pctx);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiWindow* GetCurrentWindowReadNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*>)funcTable[989])();
			#else
			return (ImGuiWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[989])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr GetCurrentWindowRead()
		{
			ImGuiWindowPtr ret = GetCurrentWindowReadNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiWindow* GetCurrentWindowNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*>)funcTable[990])();
			#else
			return (ImGuiWindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[990])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr GetCurrentWindow()
		{
			ImGuiWindowPtr ret = GetCurrentWindowNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiWindow* FindWindowByIDNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiWindow*>)funcTable[991])(id);
			#else
			return (ImGuiWindow*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[991])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr FindWindowByID(uint id)
		{
			ImGuiWindowPtr ret = FindWindowByIDNative(id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiWindow* FindWindowByNameNative(byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImGuiWindow*>)funcTable[992])(name);
			#else
			return (ImGuiWindow*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[992])((nint)name);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr FindWindowByName(byte* name)
		{
			ImGuiWindowPtr ret = FindWindowByNameNative(name);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr FindWindowByName(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ImGuiWindowPtr ret = FindWindowByNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr FindWindowByName(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				ImGuiWindowPtr ret = FindWindowByNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr FindWindowByName(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiWindowPtr ret = FindWindowByNameNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateWindowParentAndRootLinksNative(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parentWindow)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiWindowFlags, ImGuiWindow*, void>)funcTable[993])(window, flags, parentWindow);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiWindowFlags, nint, void>)funcTable[993])((nint)window, flags, (nint)parentWindow);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateWindowParentAndRootLinks(ImGuiWindowPtr window, ImGuiWindowFlags flags, ImGuiWindowPtr parentWindow)
		{
			UpdateWindowParentAndRootLinksNative(window, flags, parentWindow);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateWindowParentAndRootLinks(ref ImGuiWindow window, ImGuiWindowFlags flags, ImGuiWindowPtr parentWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				UpdateWindowParentAndRootLinksNative((ImGuiWindow*)pwindow, flags, parentWindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateWindowParentAndRootLinks(ImGuiWindowPtr window, ImGuiWindowFlags flags, ref ImGuiWindow parentWindow)
		{
			fixed (ImGuiWindow* pparentWindow = &parentWindow)
			{
				UpdateWindowParentAndRootLinksNative(window, flags, (ImGuiWindow*)pparentWindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateWindowParentAndRootLinks(ref ImGuiWindow window, ImGuiWindowFlags flags, ref ImGuiWindow parentWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* pparentWindow = &parentWindow)
				{
					UpdateWindowParentAndRootLinksNative((ImGuiWindow*)pwindow, flags, (ImGuiWindow*)pparentWindow);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateWindowSkipRefreshNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, void>)funcTable[994])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[994])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateWindowSkipRefresh(ImGuiWindowPtr window)
		{
			UpdateWindowSkipRefreshNative(window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateWindowSkipRefresh(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				UpdateWindowSkipRefreshNative((ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalcWindowNextAutoFitSizeNative(Vector2* pOut, ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImGuiWindow*, void>)funcTable[995])(pOut, window);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[995])((nint)pOut, (nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcWindowNextAutoFitSize(ImGuiWindowPtr window)
		{
			Vector2 ret;
			CalcWindowNextAutoFitSizeNative(&ret, window);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWindowNextAutoFitSize(Vector2* pOut, ImGuiWindowPtr window)
		{
			CalcWindowNextAutoFitSizeNative(pOut, window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWindowNextAutoFitSize(ref Vector2 pOut, ImGuiWindowPtr window)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcWindowNextAutoFitSizeNative((Vector2*)ppOut, window);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcWindowNextAutoFitSize(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				CalcWindowNextAutoFitSizeNative(&ret, (ImGuiWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWindowNextAutoFitSize(Vector2* pOut, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				CalcWindowNextAutoFitSizeNative(pOut, (ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWindowNextAutoFitSize(ref Vector2 pOut, ref ImGuiWindow window)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					CalcWindowNextAutoFitSizeNative((Vector2*)ppOut, (ImGuiWindow*)pwindow);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowChildOfNative(ImGuiWindow* window, ImGuiWindow* potentialParent, byte popupHierarchy, byte dockHierarchy)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiWindow*, byte, byte, byte>)funcTable[996])(window, potentialParent, popupHierarchy, dockHierarchy);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte, byte, byte>)funcTable[996])((nint)window, (nint)potentialParent, popupHierarchy, dockHierarchy);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowChildOf(ImGuiWindowPtr window, ImGuiWindowPtr potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			byte ret = IsWindowChildOfNative(window, potentialParent, popupHierarchy ? (byte)1 : (byte)0, dockHierarchy ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowChildOf(ref ImGuiWindow window, ImGuiWindowPtr potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = IsWindowChildOfNative((ImGuiWindow*)pwindow, potentialParent, popupHierarchy ? (byte)1 : (byte)0, dockHierarchy ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowChildOf(ImGuiWindowPtr window, ref ImGuiWindow potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			fixed (ImGuiWindow* ppotentialParent = &potentialParent)
			{
				byte ret = IsWindowChildOfNative(window, (ImGuiWindow*)ppotentialParent, popupHierarchy ? (byte)1 : (byte)0, dockHierarchy ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowChildOf(ref ImGuiWindow window, ref ImGuiWindow potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* ppotentialParent = &potentialParent)
				{
					byte ret = IsWindowChildOfNative((ImGuiWindow*)pwindow, (ImGuiWindow*)ppotentialParent, popupHierarchy ? (byte)1 : (byte)0, dockHierarchy ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowWithinBeginStackOfNative(ImGuiWindow* window, ImGuiWindow* potentialParent)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiWindow*, byte>)funcTable[997])(window, potentialParent);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[997])((nint)window, (nint)potentialParent);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowWithinBeginStackOf(ImGuiWindowPtr window, ImGuiWindowPtr potentialParent)
		{
			byte ret = IsWindowWithinBeginStackOfNative(window, potentialParent);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowWithinBeginStackOf(ref ImGuiWindow window, ImGuiWindowPtr potentialParent)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = IsWindowWithinBeginStackOfNative((ImGuiWindow*)pwindow, potentialParent);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowWithinBeginStackOf(ImGuiWindowPtr window, ref ImGuiWindow potentialParent)
		{
			fixed (ImGuiWindow* ppotentialParent = &potentialParent)
			{
				byte ret = IsWindowWithinBeginStackOfNative(window, (ImGuiWindow*)ppotentialParent);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowWithinBeginStackOf(ref ImGuiWindow window, ref ImGuiWindow potentialParent)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* ppotentialParent = &potentialParent)
				{
					byte ret = IsWindowWithinBeginStackOfNative((ImGuiWindow*)pwindow, (ImGuiWindow*)ppotentialParent);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowAboveNative(ImGuiWindow* potentialAbove, ImGuiWindow* potentialBelow)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiWindow*, byte>)funcTable[998])(potentialAbove, potentialBelow);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[998])((nint)potentialAbove, (nint)potentialBelow);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowAbove(ImGuiWindowPtr potentialAbove, ImGuiWindowPtr potentialBelow)
		{
			byte ret = IsWindowAboveNative(potentialAbove, potentialBelow);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowAbove(ref ImGuiWindow potentialAbove, ImGuiWindowPtr potentialBelow)
		{
			fixed (ImGuiWindow* ppotentialAbove = &potentialAbove)
			{
				byte ret = IsWindowAboveNative((ImGuiWindow*)ppotentialAbove, potentialBelow);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowAbove(ImGuiWindowPtr potentialAbove, ref ImGuiWindow potentialBelow)
		{
			fixed (ImGuiWindow* ppotentialBelow = &potentialBelow)
			{
				byte ret = IsWindowAboveNative(potentialAbove, (ImGuiWindow*)ppotentialBelow);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowAbove(ref ImGuiWindow potentialAbove, ref ImGuiWindow potentialBelow)
		{
			fixed (ImGuiWindow* ppotentialAbove = &potentialAbove)
			{
				fixed (ImGuiWindow* ppotentialBelow = &potentialBelow)
				{
					byte ret = IsWindowAboveNative((ImGuiWindow*)ppotentialAbove, (ImGuiWindow*)ppotentialBelow);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWindowNavFocusableNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, byte>)funcTable[999])(window);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[999])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowNavFocusable(ImGuiWindowPtr window)
		{
			byte ret = IsWindowNavFocusableNative(window);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsWindowNavFocusable(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = IsWindowNavFocusableNative((ImGuiWindow*)pwindow);
				return ret != 0;
			}
		}

		/// <summary>
		/// (not recommended) set current window position - call within Begin()End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowPosNative(ImGuiWindow* window, Vector2 pos, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, Vector2, ImGuiCond, void>)funcTable[1000])(window, pos, cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, ImGuiCond, void>)funcTable[1000])((nint)window, pos, cond);
			#endif
		}

		/// <summary>
		/// (not recommended) set current window position - call within Begin()End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.<br/>
		/// </summary>
		public static void SetWindowPos(ImGuiWindowPtr window, Vector2 pos, ImGuiCond cond)
		{
			SetWindowPosNative(window, pos, cond);
		}

		/// <summary>
		/// (not recommended) set current window position - call within Begin()End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.<br/>
		/// </summary>
		public static void SetWindowPos(ImGuiWindowPtr window, Vector2 pos)
		{
			SetWindowPosNative(window, pos, (ImGuiCond)(0));
		}

		/// <summary>
		/// (not recommended) set current window position - call within Begin()End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.<br/>
		/// </summary>
		public static void SetWindowPos(ref ImGuiWindow window, Vector2 pos, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowPosNative((ImGuiWindow*)pwindow, pos, cond);
			}
		}

		/// <summary>
		/// (not recommended) set current window position - call within Begin()End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.<br/>
		/// </summary>
		public static void SetWindowPos(ref ImGuiWindow window, Vector2 pos)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowPosNative((ImGuiWindow*)pwindow, pos, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// (not recommended) set current window size - call within Begin()End(). set to ImVec2(0, 0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowSizeNative(ImGuiWindow* window, Vector2 size, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, Vector2, ImGuiCond, void>)funcTable[1001])(window, size, cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, ImGuiCond, void>)funcTable[1001])((nint)window, size, cond);
			#endif
		}

		/// <summary>
		/// (not recommended) set current window size - call within Begin()End(). set to ImVec2(0, 0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.<br/>
		/// </summary>
		public static void SetWindowSize(ImGuiWindowPtr window, Vector2 size, ImGuiCond cond)
		{
			SetWindowSizeNative(window, size, cond);
		}

		/// <summary>
		/// (not recommended) set current window size - call within Begin()End(). set to ImVec2(0, 0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.<br/>
		/// </summary>
		public static void SetWindowSize(ImGuiWindowPtr window, Vector2 size)
		{
			SetWindowSizeNative(window, size, (ImGuiCond)(0));
		}

		/// <summary>
		/// (not recommended) set current window size - call within Begin()End(). set to ImVec2(0, 0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.<br/>
		/// </summary>
		public static void SetWindowSize(ref ImGuiWindow window, Vector2 size, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowSizeNative((ImGuiWindow*)pwindow, size, cond);
			}
		}

		/// <summary>
		/// (not recommended) set current window size - call within Begin()End(). set to ImVec2(0, 0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.<br/>
		/// </summary>
		public static void SetWindowSize(ref ImGuiWindow window, Vector2 size)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowSizeNative((ImGuiWindow*)pwindow, size, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowCollapsedNative(ImGuiWindow* window, byte collapsed, ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, byte, ImGuiCond, void>)funcTable[1002])(window, collapsed, cond);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, ImGuiCond, void>)funcTable[1002])((nint)window, collapsed, cond);
			#endif
		}

		/// <summary>
		/// (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().<br/>
		/// </summary>
		public static void SetWindowCollapsed(ImGuiWindowPtr window, bool collapsed, ImGuiCond cond)
		{
			SetWindowCollapsedNative(window, collapsed ? (byte)1 : (byte)0, cond);
		}

		/// <summary>
		/// (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().<br/>
		/// </summary>
		public static void SetWindowCollapsed(ImGuiWindowPtr window, bool collapsed)
		{
			SetWindowCollapsedNative(window, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		/// <summary>
		/// (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().<br/>
		/// </summary>
		public static void SetWindowCollapsed(ref ImGuiWindow window, bool collapsed, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowCollapsedNative((ImGuiWindow*)pwindow, collapsed ? (byte)1 : (byte)0, cond);
			}
		}

		/// <summary>
		/// (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().<br/>
		/// </summary>
		public static void SetWindowCollapsed(ref ImGuiWindow window, bool collapsed)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowCollapsedNative((ImGuiWindow*)pwindow, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowHitTestHoleNative(ImGuiWindow* window, Vector2 pos, Vector2 size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, Vector2, Vector2, void>)funcTable[1003])(window, pos, size);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, void>)funcTable[1003])((nint)window, pos, size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowHitTestHole(ImGuiWindowPtr window, Vector2 pos, Vector2 size)
		{
			SetWindowHitTestHoleNative(window, pos, size);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowHitTestHole(ref ImGuiWindow window, Vector2 pos, Vector2 size)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowHitTestHoleNative((ImGuiWindow*)pwindow, pos, size);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowHiddenAndSkipItemsForCurrentFrameNative(ImGuiWindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, void>)funcTable[1004])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1004])((nint)window);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowHiddenAndSkipItemsForCurrentFrame(ImGuiWindowPtr window)
		{
			SetWindowHiddenAndSkipItemsForCurrentFrameNative(window);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetWindowHiddenAndSkipItemsForCurrentFrame(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowHiddenAndSkipItemsForCurrentFrameNative((ImGuiWindow*)pwindow);
			}
		}

		/// <summary>
		/// You may also use SetNextWindowClass()'s FocusRouteParentWindowId field.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetWindowParentWindowForFocusRouteNative(ImGuiWindow* window, ImGuiWindow* parentWindow)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImGuiWindow*, void>)funcTable[1005])(window, parentWindow);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[1005])((nint)window, (nint)parentWindow);
			#endif
		}

		/// <summary>
		/// You may also use SetNextWindowClass()'s FocusRouteParentWindowId field.<br/>
		/// </summary>
		public static void SetWindowParentWindowForFocusRoute(ImGuiWindowPtr window, ImGuiWindowPtr parentWindow)
		{
			SetWindowParentWindowForFocusRouteNative(window, parentWindow);
		}

		/// <summary>
		/// You may also use SetNextWindowClass()'s FocusRouteParentWindowId field.<br/>
		/// </summary>
		public static void SetWindowParentWindowForFocusRoute(ref ImGuiWindow window, ImGuiWindowPtr parentWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				SetWindowParentWindowForFocusRouteNative((ImGuiWindow*)pwindow, parentWindow);
			}
		}

		/// <summary>
		/// You may also use SetNextWindowClass()'s FocusRouteParentWindowId field.<br/>
		/// </summary>
		public static void SetWindowParentWindowForFocusRoute(ImGuiWindowPtr window, ref ImGuiWindow parentWindow)
		{
			fixed (ImGuiWindow* pparentWindow = &parentWindow)
			{
				SetWindowParentWindowForFocusRouteNative(window, (ImGuiWindow*)pparentWindow);
			}
		}

		/// <summary>
		/// You may also use SetNextWindowClass()'s FocusRouteParentWindowId field.<br/>
		/// </summary>
		public static void SetWindowParentWindowForFocusRoute(ref ImGuiWindow window, ref ImGuiWindow parentWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* pparentWindow = &parentWindow)
				{
					SetWindowParentWindowForFocusRouteNative((ImGuiWindow*)pwindow, (ImGuiWindow*)pparentWindow);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowRectAbsToRelNative(ImRect* pOut, ImGuiWindow* window, ImRect r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiWindow*, ImRect, void>)funcTable[1006])(pOut, window, r);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, ImRect, void>)funcTable[1006])((nint)pOut, (nint)window, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect WindowRectAbsToRel(ImGuiWindowPtr window, ImRect r)
		{
			ImRect ret;
			WindowRectAbsToRelNative(&ret, window, r);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowRectAbsToRel(ImRectPtr pOut, ImGuiWindowPtr window, ImRect r)
		{
			WindowRectAbsToRelNative(pOut, window, r);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowRectAbsToRel(ref ImRect pOut, ImGuiWindowPtr window, ImRect r)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				WindowRectAbsToRelNative((ImRect*)ppOut, window, r);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect WindowRectAbsToRel(ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImRect ret;
				WindowRectAbsToRelNative(&ret, (ImGuiWindow*)pwindow, r);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowRectAbsToRel(ImRectPtr pOut, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				WindowRectAbsToRelNative(pOut, (ImGuiWindow*)pwindow, r);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowRectAbsToRel(ref ImRect pOut, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					WindowRectAbsToRelNative((ImRect*)ppOut, (ImGuiWindow*)pwindow, r);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowRectRelToAbsNative(ImRect* pOut, ImGuiWindow* window, ImRect r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiWindow*, ImRect, void>)funcTable[1007])(pOut, window, r);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, ImRect, void>)funcTable[1007])((nint)pOut, (nint)window, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect WindowRectRelToAbs(ImGuiWindowPtr window, ImRect r)
		{
			ImRect ret;
			WindowRectRelToAbsNative(&ret, window, r);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowRectRelToAbs(ImRectPtr pOut, ImGuiWindowPtr window, ImRect r)
		{
			WindowRectRelToAbsNative(pOut, window, r);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowRectRelToAbs(ref ImRect pOut, ImGuiWindowPtr window, ImRect r)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				WindowRectRelToAbsNative((ImRect*)ppOut, window, r);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect WindowRectRelToAbs(ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImRect ret;
				WindowRectRelToAbsNative(&ret, (ImGuiWindow*)pwindow, r);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowRectRelToAbs(ImRectPtr pOut, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				WindowRectRelToAbsNative(pOut, (ImGuiWindow*)pwindow, r);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void WindowRectRelToAbs(ref ImRect pOut, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					WindowRectRelToAbsNative((ImRect*)ppOut, (ImGuiWindow*)pwindow, r);
				}
			}
		}
	}
}
